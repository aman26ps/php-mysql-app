name: Deploy PHP MySQL App

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-east-1
      STACK_NAME: php-app-stack
      ECR_REPOSITORY: php-mysql-app
      IMAGE_TAG: latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python (for cfn-lint)
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install cfn-lint
        run: pip install cfn-lint

      - name: Lint CloudFormation templates
        run: |
          find cloudformation -name "*.yml" -o -name "*.yaml" | xargs -I {} cfn-lint {} || true

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/cf-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Create EC2 KeyPair from SSM (if not exists)
        run: |
          if ! aws ec2 describe-key-pairs --key-names php-app-key 2>/dev/null; then
            echo "Creating EC2 KeyPair from SSM parameter..."
            aws ssm get-parameter \
              --name "/phpapp/public-key" \
              --region "$AWS_REGION" \
              --query 'Parameter.Value' \
              --output text > public-key.txt

            cat public-key.txt

            aws ec2 import-key-pair \
              --key-name php-app-key \
              --public-key-material fileb://public-key.txt \
              --region "$AWS_REGION"
          else
            echo "KeyPair already exists. Skipping creation."
          fi

      - name: Deploy CloudFormation stack
        run: |
          aws cloudformation deploy \
            --template-file cloudformation/ec2-rds-alb.yml \
            --stack-name "$STACK_NAME" \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides KeyName=php-app-key \
            --no-fail-on-empty-changeset

      - name: Build & push Docker image to ECR
        run: |
          REPO_URI=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY --query 'repositories[0].repositoryUri' --output text)
          echo "REPO_URI=$REPO_URI" >> $GITHUB_ENV

          echo "Logging in to ECR..."
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $REPO_URI

          echo "Building and pushing image..."
          docker compose -f docker/docker-compose.yml build app
          docker tag php-mysql-app:latest $REPO_URI:$IMAGE_TAG
          docker push $REPO_URI:$IMAGE_TAG

      - name: Update EC2 via SSM
        run: |
          set -euo pipefail
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters Name=tag:Name,Values=PHPAppEC2 \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          RDS_HOST=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='RDSHost'].OutputValue" \
            --output text)

          echo "🔄 Sending command to EC2 via SSM..."
          COMMANDS=$(cat <<EOF
          [
            "sh -c '
              DB_USER=\$(aws ssm get-parameter --name /phpapp/db_username --with-decryption --output text --query Parameter.Value --region us-east-1) &&
              DB_PASS=\$(aws ssm get-parameter --name /phpapp/db_password --with-decryption --output text --query Parameter.Value --region us-east-1) &&
              aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $REPO_URI &&
              docker pull $REPO_URI:$IMAGE_TAG &&
              docker stop php_app || true &&
              docker rm php_app || true &&
              docker run -d --name php_app -p 80:80 \
                -e DB_NAME=optimy_db \
                -e DB_HOST=$RDS_HOST \
                -e DB_USER=\$DB_USER \
                -e DB_PASS=\$DB_PASS \
                $REPO_URI:$IMAGE_TAG
            '"
          ]
          EOF
          )


          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy latest Docker image with env vars" \
            --parameters commands="$COMMANDS" \
            --region "$AWS_REGION" \
            --query 'Command.CommandId' \
            --output text)

          echo "⏳ Waiting for SSM command [$CMD_ID] to execute..."
          sleep 20  # give the agent time to process

          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "$AWS_REGION" \
            --output json)

          STATUS=$(echo "$OUTPUT" | jq -r '.Status')
          STDOUT=$(echo "$OUTPUT" | jq -r '.StandardOutputContent')
          STDERR=$(echo "$OUTPUT" | jq -r '.StandardErrorContent')

          echo "::group::📝 SSM Command Output"
          echo "$STDOUT"
          echo "::endgroup::"

          echo "::group::❗SSM Command Error"
          echo "$STDERR"
          echo "::endgroup::"

          echo "::group::📦 Raw Command Payload"
          echo "$OUTPUT"
          echo "::endgroup::"

          if [[ "$STATUS" != "Success" ]]; then
            echo "❌ SSM command failed with status: $STATUS"
            exit 1
          else
            echo "✅ SSM command completed successfully"
          fi

      - name: Tar and base64 encode monitoring files
        run: |
          mkdir -p deploy/tmp
          cp docker/docker-compose.monitoring.yml deploy/tmp/
          cp monitoring/agent.alloy.template deploy/tmp/
          tar -czf deploy/monitoring.tar.gz -C deploy/tmp .
          base64 deploy/monitoring.tar.gz > deploy/monitoring.tar.gz.b64
          echo "FILE_CONTENT<<EOF" >> $GITHUB_ENV
          cat deploy/monitoring.tar.gz.b64 >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Send monitoring files and deploy via SSM with logs
        run: |
          echo "📤 Sending SSM command to EC2..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids $SSM_INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy monitoring stack (Alloy)" \
            --parameters 'commands=[
              "echo ✅ Creating monitoring folders...",
              "mkdir -p /opt/monitoring/docker",
              "mkdir -p /opt/monitoring/monitoring",

              "echo ✅ Decoding and extracting tarball...",
              "echo ${{ env.FILE_CONTENT }} | base64 -d > /opt/monitoring/monitoring.tar.gz",
              "tar -xzf /opt/monitoring/monitoring.tar.gz -C /opt/monitoring/",

              "echo ✅ Fetching Grafana token from SSM...",
              "export GRAFANA_BEARER_TOKEN=$(aws ssm get-parameter --name /grafana/bearer_token --with-decryption --query Parameter.Value --output text)",

              "echo ✅ Generating agent.alloy config...",
              "envsubst < /opt/monitoring/monitoring/agent.alloy.template > /opt/monitoring/monitoring/agent.alloy",
              "cat /opt/monitoring/monitoring/agent.alloy",

              "echo ✅ Restarting monitoring stack...",
              "docker compose -f /opt/monitoring/docker/docker-compose.monitoring.yml down || true",
              "docker compose -f /opt/monitoring/docker/docker-compose.monitoring.yml up -d",

              "echo ✅ Deployment finished."
            ]' \
            --region $AWS_REGION \
            --output text \
            --query 'Command.CommandId')

          echo "🪪 Command ID: $COMMAND_ID"
          echo "⏳ Waiting for command to finish..."

          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id $SSM_INSTANCE_ID \
            --region $AWS_REGION

          echo "📄 Fetching command output..."
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id $SSM_INSTANCE_ID \
            --region $AWS_REGION \
            --output text \
            --query 'StandardOutputContent'

  functional-test:
    needs: deploy
    runs-on: ubuntu-latest
    env:
      STACK_NAME: php-app-stack
      AWS_REGION: us-east-1
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/cf-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Public IP from CloudFormation
        id: getip
        run: |
          PUBLIC_IP=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='EC2PublicIP'].OutputValue" \
            --output text)
          echo "App URL: http://$PUBLIC_IP"
          echo "APP_URL=http://$PUBLIC_IP" >> $GITHUB_ENV

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright dependencies
        run: |
          cd tests
          npm ci
          npx playwright install --with-deps

      - name: Run Playwright functional test
        run: |
          cd tests
          npm test
        
